# 构建工具

## webpack VS vite

### 核心理念 — bundle与否

`webpack`使用`Node.js` 编写的打包器从入口点开始逐步构建一个依赖图，然后将项目中所需的模块组合成一个或多个`bundle`文件，即逐级递归识别依赖，构建依赖图谱；

`vite`无需进行`bundle`操作，源文件之间的依赖关系通过浏览器对 ESM 规范的支持来解析，将应用中的模块区分为 依赖(`node_modules`) 和 源码(项目代码) 两类；

- 依赖：使用`esbuild`预构建，`esbuild`使用`Go`编写，比以`Node.js`编写的打包器预构建依赖快10-100倍；
- 源码：在浏览器请求时**按需**转换并以原生`ESM`方式提供源码，让浏览器接管了打包程序的部分工作；

### 首屏、懒加载性能

由于`webpack`本身是经过了漫长的`bundle`过程，得到了一个完整的模块关系依赖包，所以不存在这两个方面的问题；

而`vite`由于`unBundle`机制，首屏、懒加载会存在一定的问题，处理时需要额外做以下工作：

- 由于未对源文件做合并捆绑操作，导致大量的`http`请求；
- 动态加载的文件需要对源文件进行转换操作：`resolve、load、transform、parse`；
- 预构建、二次预构建操作也会阻塞首屏请求，直到预构建完成为止；
- 但是由于缓存的存在，当第一次加载完成(预构建)之后，再次reload的时候性能会有较大的提升 ;

### 服务启动速度

`webpack`需要先把所有的模块建立依赖关系打包成一个大文件，速度相对较慢；

`vite`将应用中的模块区分为 依赖(`node_modules`) 和 源码(项目代码) 两类，进行预构建，速度会快很多；

- 依赖：使用`esbuild`预构建，`esbuild`使用`Go`编写，比以`Node.js`编写的打包器预构建依赖快10-100倍；
  - 初次预构建完成后，会在`node_modules`中生成 `.vite`文件，后期不需要再次进行依赖的预构建；
- 源码：在浏览器请求时**按需**转换并以原生`ESM`方式提供源码，让浏览器接管了打包程序的部分工作；
  - 由于是按需提供，所以在首屏、懒加载方面相比于`webpack`会存在一定的差异；

### 热更新速度

webpack：

- 编辑文件后将重新构建文件本身;
- 显然我们不应该重新构建整个包，因为这样更新速度会随着应用体积增长而直线下降；
- 所以打包器支持了动态模块热重载`HMR(Hot Module Replacing)`，而对页面其余部分没有影响，这较大的提升了开发体验；
- 然而，在实践中发现即使是HMR，更新速度也会随着应用规模的增长而显著下降；

vite：

- 在`vite`中，`HMR`是在原生`ESM`上执行的，当编辑一个文件时，只需要精确地使已编辑的模块与其最近的 `HMR`边界之间的链失效(大多数时候只需要模块本身)，使`HMR`更新始终快速，无论应用的大小；
- `vite`同时利用`HTTP`头来加速整个页面的重新加载(再次让浏览器为我们做更多事情)：
  - 源码模块的请求会根据`304 Not Modified`进行协商缓存；
  - 依赖模块请求则会通过 Cache-Control: max-age=31536000,immutable进行强缓存;

### prod环境打包区别

`webpack`在生产环境的构建方面更加成熟，`bundle`整体形成完善的依赖关系，也有非常多的`loader`或者`plugin`可供选择；

`vite`在生产环境的构建目前用的`Rollup`：

- `vite`在生产环境，如果使用`ESM`会存在大量额外网络请求问题：
  - 尽管原生 `ESM` 现在得到了广泛支持，但由于嵌套导入会导致额外的网络往返，在生产环境中发布未打包的 `ESM` 仍然效率低下 ；
  - 最好的方式还是代码进行 `tree-shaking、懒加载、和 chunk 分隔`等；
- 使用 `rollup`打包而不是速度惊人的`esbuild`，这是因为`esbuild`针对构建应用的重要功能仍然还在持续开发中 —— 特别是代码分割和`css`处理方面，`rollup`在应用打包方面更加的成熟且灵活；
- 当未来这些功能稳定后，也不排除使用 `esbuild` 作为生产构建器的可能；

### 生态成熟度

- `webpack`拥有一个庞大的生态系统，有非常多优秀的`loader`和`plugin`可供选择(毕竟是老大哥)；
- `vite`生态成熟度目前不如`webpack`，但也在很大程度上满足常规开发所需，赶上也只是时间问题；

### 总结

`vite` 的核心理念就是借助浏览器原生 `ES Modules` 能力，当浏览器发出请求时，为浏览器按需提供 `ES Module` 文件，浏览器获取 `ES Module` 文件会直接执行，即使首次启动的预构建也是使用速度惊人的`esbuild`完成，虽然存在一些小的问题（例如：首屏、懒加载性能），但瑕不掩瑜，速度、效率、体验已非`webpack`可比，我自己在最近的项目工作中也是使用的`vite`（项目从0到1），感觉`nice`。

当面试官问到这两个工程化工具之间的区别，大家可以从以上几个方面去聊一聊，理清思路、抓住重点、侃侃而谈，相信会为你的面试加分！

## webpack

### loader vs plugin

前面两节我们有提到 `Loader` 与 `Plugin` 对应的概念，先来回顾下

- `loader` 是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中
- `plugin` 赋予了 `webpack` 各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是解决 `loader` 无法实现的其他事

从整个运行时机上来看，可以看到，两者在运行时机上的区别：

- `loader` 运行在打包文件之前
- `plugin` 在整个编译周期都起作用

在 `Webpack` 运行的生命周期中会广播出许多事件，`Plugin` 可以监听这些事件，在合适的时机通过 `Webpack` 提供的 `API` 改变输出结果 对于`loader`，实质是一个转换器，将A文件进行编译形成B文件，操作的是文件，比如将 `A.scss` 或 `A.less` 转变为 `B.css`，单纯的文件转换过程

## vite
